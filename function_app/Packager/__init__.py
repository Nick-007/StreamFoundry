from __future__ import annotations
import json, time
from typing import List, Tuple, Optional, Dict, Any
from pathlib import Path

import azure.functions as func
from azure.storage.queue import QueueClient
from azure.core.exceptions import ResourceNotFoundError

from .. import app
# ---------- shared helpers you already have ----------
from ..shared.logger import (
    log_job as _log_job, 
    log_exception as _log_exception, 
    StreamLogger, 
    bridge_logger
)
from ..shared.storage import upload_bytes, upload_tree_routed
from ..shared.qc import _safe_json
from ..shared.config import get

HLS        = get("HLS_CONTAINER",      "hls")
DASH       = get("DASH_CONTAINER",     "dash")
PROCESSED  = get("PROCESSED_CONTAINER","processed")
LOGS       = get("LOGS_CONTAINER",     "logs")
TMP_ROOT   = get("TMP_DIR",            "/tmp/ingestor")
SEG_DUR    = int(get("SEG_DUR_SEC",    "4"))
AUDIO_TS   = int(get("AUDIO_TIMESCALE","44100"))
VIDEO_TS   = int(get("VIDEO_TIMESCALE","24000"))
PKG_Q    = get("PACKAGING_QUEUE", "packaging-jobs")

# Packager — helpers
from ..shared.errors import BadMessageError
def _queue_client(name: str) -> QueueClient:
    conn = get("AzureWebJobsStorage") or get("AZURE_STORAGE_CONNECTION_STRING")
    return QueueClient.from_connection_string(conn, name)

def _normalize_pkg(p: dict):
    stem = p.get("stem") or p.get("job_id") or p.get("id")
    dist_dir = p.get("dist_dir") or p.get("output") or p.get("dist")
    if not stem:    raise BadMessageError("Missing required field: stem")
    if not dist_dir:raise BadMessageError("Missing required field: dist_dir")
    return {"stem": stem, "dist_dir": dist_dir, "ts": p.get("ts")}

def send_to_poison(msg: func.QueueMessage, *, queue_name: str, reason: str, details: dict | None = None):
    poison = f"{queue_name}-poison"
    qc = _queue_client(poison)
    try:
        body = msg.get_body().decode("utf-8", errors="ignore")
    except Exception:
        body = "<unreadable>"
    payload = {
        "reason": reason,
        "details": details or {},
        "original": {
            "id": getattr(msg, "id", None),
            "dequeue_count": getattr(msg, "dequeue_count", None),
            "insertion_time": getattr(msg, "insertion_time", None).isoformat() if getattr(msg, "insertion_time", None) else None,
            "body": body,
        },
        "moved_at": int(time.time())
    }
    # No auto-create; fail if poison queue missing so infra issues are visible
    try:
        qc.send_message(json.dumps(payload))
    except ResourceNotFoundError:
        raise RuntimeError(f"Poison queue '{poison}' not found. Seed infra first.")

# ---------- tiny logging bridge ----------
def _pylog(s: str): print(f"{time.strftime('%Y-%m-%d %H:%M:%S')}Z INFO Function.packager | {s}")

def _safe_log_job(topic: str, msg: str, **kv):
    try: _log_job(topic, msg, **kv)
    except Exception: pass

def _safe_log_exc(topic: str, msg: str, **kv):
    try: _log_exception(topic, msg, **kv)
    except Exception: pass

# ---------- CMAF scan ----------
def _collect_video_rungs(work_dir: str) -> List[Tuple[str, Path, int]]:
    out: List[Tuple[str, Path, int]] = []
    base = Path(work_dir) / "cmaf" / "video"
    if not base.exists(): return out
    for rung in sorted(p for p in base.iterdir() if p.is_dir()):
        label = rung.name  # "240p", "360p", ...
        init  = rung / f"video_{label}_init.mp4"
        if not init.exists(): continue
        segs = sorted(rung.glob(f"video_{label}_*.m4s"))
        out.append((label, rung, len(segs)))
    return out

def _collect_audio(work_dir: str) -> Tuple[Optional[Path], int]:
    adir = Path(work_dir) / "cmaf" / "audio"
    if not adir.exists(): return (None, 0)
    if not (adir / "audio_init.m4a").exists(): return (None, 0)
    segs = sorted(adir.glob("audio_*.m4s"))
    return (adir, len(segs))

# ---------- Manifest writers (VOD) ----------
def _write_dash_vod(*, out_path: Path, video_rungs, audio, seg_dur_sec: int) -> None:
    (audio_dir, a_count) = audio
    mpd: List[str] = []
    mpd.append('<?xml version="1.0" encoding="UTF-8"?>')
    mpd.append('<!--Generated by Packager (CMAF VOD, template-duration)-->')
    mpd.append('<MPD xmlns="urn:mpeg:dash:schema:mpd:2011" profiles="urn:mpeg:dash:profile:isoff-live:2011" type="static" minBufferTime="PT2S">')
    mpd.append('  <Period id="0">')

    mpd.append('    <AdaptationSet id="0" contentType="video" segmentAlignment="true">')
    for (label, _, _) in video_rungs:
        try: height = int(label.rstrip("p"))
        except: height = 0
        init_name = f"video_{label}_init.mp4"
        media_tpl = f"video_{label}_$Number$.m4s"
        duration  = seg_dur_sec * VIDEO_TS
        mpd.append(f'      <Representation id="{label}" mimeType="video/mp4" codecs="avc1.640029" height="{height}">')
        mpd.append(f'        <SegmentTemplate timescale="{VIDEO_TS}" initialization="{init_name}" media="{media_tpl}" duration="{duration}" startNumber="1"/>')
        mpd.append('      </Representation>')
    mpd.append('    </AdaptationSet>')

    if audio_dir is not None and a_count > 0:
        duration = seg_dur_sec * AUDIO_TS
        mpd.append('    <AdaptationSet id="1" contentType="audio" lang="en" segmentAlignment="true">')
        mpd.append(f'      <Representation id="audio" mimeType="audio/mp4" codecs="mp4a.40.2" audioSamplingRate="{AUDIO_TS}">')
        mpd.append(f'        <SegmentTemplate timescale="{AUDIO_TS}" initialization="audio_init.m4a" media="audio_$Number$.m4s" duration="{duration}" startNumber="1"/>')
        mpd.append('      </Representation>')
        mpd.append('    </AdaptationSet>')

    mpd.append('  </Period>')
    mpd.append('</MPD>')
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text("\n".join(mpd), encoding="utf-8")

def _write_hls_vod(*, out_dir: Path, video_rungs, audio, seg_dur_sec: int) -> None:
    out_dir.mkdir(parents=True, exist_ok=True)

    # video variants
    for (label, _, segs) in video_rungs:
        m3u = [
            "#EXTM3U",
            "#EXT-X-VERSION:7",
            f"#EXT-X-TARGETDURATION:{seg_dur_sec}",
            "#EXT-X-MEDIA-SEQUENCE:0",
            "#EXT-X-PLAYLIST-TYPE:VOD",
            f'#EXT-X-MAP:URI="video_{label}_init.mp4"',
        ]
        for i in range(1, segs + 1):
            m3u.append(f"#EXTINF:{seg_dur_sec:.3f},")
            m3u.append(f"video_{label}_{i}.m4s")
        m3u.append("#EXT-X-ENDLIST")
        (out_dir / f"video_{label}.m3u8").write_text("\n".join(m3u), encoding="utf-8")

    # audio
    (audio_dir, a_count) = audio
    has_audio = audio_dir is not None and a_count > 0
    if has_audio:
        am3u = [
            "#EXTM3U",
            "#EXT-X-VERSION:7",
            f"#EXT-X-TARGETDURATION:{seg_dur_sec}",
            "#EXT-X-MEDIA-SEQUENCE:0",
            "#EXT-X-PLAYLIST-TYPE:VOD",
            '#EXT-X-MAP:URI="audio_init.m4a"',
        ]
        for i in range(1, a_count + 1):
            am3u.append(f"#EXTINF:{seg_dur_sec:.3f},")
            am3u.append(f"audio_{i}.m4s")
        am3u.append("#EXT-X-ENDLIST")
        (out_dir / "audio.m3u8").write_text("\n".join(am3u), encoding="utf-8")

    # master
    master = ["#EXTM3U", "#EXT-X-VERSION:7"]
    if has_audio:
        master.append('#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="audio",NAME="English",LANGUAGE="en",AUTOSELECT=YES,DEFAULT=YES,URI="audio.m3u8"')
    for (label, _, _) in video_rungs:
        master.append('#EXT-X-STREAM-INF:BANDWIDTH=800000' + (',AUDIO="audio"' if has_audio else ''))
        master.append(f"video_{label}.m3u8")
    (out_dir / "master.m3u8").write_text("\n".join(master), encoding="utf-8")

# ---------- core handler ----------
def _handle_packaging(payload: Dict[str, Any], log) -> None:
    stem     = payload.get("stem") or payload.get("job_id")
    dist_dir = payload.get("dist_dir") or str(Path(TMP_ROOT)/stem/"dist")
    work_dir = payload.get("work_dir") or str(Path(TMP_ROOT)/stem/"work")
    if not stem:
        raise ValueError("packager payload missing 'stem'")

    vids = _collect_video_rungs(work_dir)
    aud  = _collect_audio(work_dir)
    if not vids and (aud[0] is None or aud[1] == 0):
        raise FileNotFoundError("No CMAF outputs found to package")

    log(f"[package] CMAF scan video={[(l,c) for (l,_,c) in vids]} audio={aud[1]}")

    dash_path = Path(dist_dir) / "dash" / "stream.mpd"
    hls_dir   = Path(dist_dir) / "hls"
    _write_dash_vod(out_path=dash_path, video_rungs=vids, audio=aud, seg_dur_sec=SEG_DUR)
    _write_hls_vod(out_dir=hls_dir,     video_rungs=vids, audio=aud, seg_dur_sec=SEG_DUR)

    upload_tree_routed(dist_dir=str(Path(dist_dir)),
                       stem=stem,
                       hls_container=HLS,
                       dash_container=DASH,
                       strategy="idempotent",
                       log=log)

    version = f"{int(time.time())}"
    manifest = {
        "id": stem,
        "version": version,
        "hls": f"{HLS}/{stem}/master.m3u8",
        "dash": f"{DASH}/{stem}/stream.mpd",
        "updatedAt": int(time.time()),
    }
    upload_bytes(PROCESSED, f"{stem}/manifest.json", json.dumps(manifest, indent=2).encode("utf-8"), "application/json")
    upload_bytes(PROCESSED, f"{stem}/latest.json",   json.dumps({"version": version, "updatedAt": int(time.time())}).encode("utf-8"), "application/json")

    log(f"[package] done → dist={dist_dir}")
    _safe_log_job("package", "done", stem=stem, dist=dist_dir)

# ---------- Queue trigger (v2 decorators) ----------
@app.function_name(name="Packager")
@app.queue_trigger(arg_name="msg",
                   queue_name=PKG_Q,
                   connection="AzureWebJobsStorage")
def packager(msg: func.QueueMessage, context: func.Context):
    qname = get("PACKAGING_QUEUE", "packaging-jobs")
    raw = msg.get_body().decode("utf-8", "ignore")
    try:
        payload = _normalize_pkg(_safe_json(raw, allow_plain=True))
    except BadMessageError as e:
        # unrecoverable payload → shunt immediately
        send_to_poison(msg, queue_name=qname, reason="bad-payload", details={"error": str(e)})
        return